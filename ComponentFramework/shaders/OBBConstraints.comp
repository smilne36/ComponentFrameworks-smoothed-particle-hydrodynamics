#version 450
layout(local_size_x = 256) in;

struct Particle {
    vec4 pos;
    vec4 vel;
    vec4 acc;
    float density;
    float pressure;
    float padA;
    float padB;
    int isGhost;
    int isActive;
    int padC;
    int pad0;
};

layout(std430, binding=0) buffer Particles { Particle particles[]; };

uniform vec3 uBoxCenter;
uniform vec3 uBoxHalf;
uniform mat3 uBoxRot;    // column-major, world_from_box
uniform float uRestitution; // 0..1
uniform float uFriction;    // 0..1

// Convert world to box-local (R^T*(p-c))
vec3 worldToLocal(vec3 p) {
    vec3 d = p - uBoxCenter;
    // uBoxRot is world_from_box, so local_from_world = transpose(uBoxRot)
    return vec3(dot(d, uBoxRot[0]), dot(d, uBoxRot[1]), dot(d, uBoxRot[2]));
}
vec3 localToWorld(vec3 q) {
    return uBoxCenter + uBoxRot * q;
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= particles.length()) return;

    // Skip ghosts
    if (particles[i].isGhost != 0) return;

    vec3 pW = particles[i].pos.xyz;
    vec3 vW = particles[i].vel.xyz;

    // Transform to box local space
    vec3 pL = worldToLocal(pW);

    // Clamp to OBB AABB in local space
    vec3 qL = clamp(pL, -uBoxHalf, uBoxHalf);

    // If clamped, compute collision response
    vec3 delta = pL - qL;
    if (any(greaterThan(abs(delta), vec3(0.0)))) {
        // Contact normal along the most violated axis (in local space)
        vec3 nL = vec3(0.0);
        vec3 d = abs(delta);
        if (d.x >= d.y && d.x >= d.z) nL = vec3(sign(delta.x), 0.0, 0.0);
        else if (d.y >= d.x && d.y >= d.z) nL = vec3(0.0, sign(delta.y), 0.0);
        else nL = vec3(0.0, 0.0, sign(delta.z));

        // Transform normal to world
        vec3 nW = normalize(uBoxRot * nL);

        // Correct position to the surface
        pW = localToWorld(qL);

        // Split velocity into normal/tangent and reflect with restitution + friction
        float vn = dot(vW, nW);
        vec3 vN = vn * nW;
        vec3 vT = vW - vN;

        vec3 vN_new = -uRestitution * vN;
        vec3 vT_new = (1.0 - uFriction) * vT;

        vW = vN_new + vT_new;
    }

    particles[i].pos.xyz = pW;
    particles[i].vel.xyz = vW;
}